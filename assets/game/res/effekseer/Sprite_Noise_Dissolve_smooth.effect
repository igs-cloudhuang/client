
CCEffect %{
  techniques:

  - name: user
    passes:
    - vert: user_vs:vert
      frag: user_fs:frag
      properties: &props
        uMatCamera: { editor: { visible: false } }
        uMatProjection: { editor: { visible: false } }
        mUVInversed: { editor: { visible: false } }
        predefined_uniform: { editor: { visible: false } }
        cameraPosition: { editor: { visible: false } }
        efk_uniform_348: { editor: { visible: false } }
        efk_uniform_358: { editor: { visible: false } }
        efk_uniform_370: { editor: { visible: false } }
        efk_uniform_479: { editor: { visible: false } }
        mUVInversedBack: { editor: { visible: false } }
        reconstructionParam1: { editor: { visible: false } }
        reconstructionParam2: { editor: { visible: false } }
        fLightDirection: { editor: { visible: false } }
        fLightColor: { editor: { visible: false } }
        fLightAmbient: { editor: { visible: false } }
  - name: model
    passes:
    - vert: model_vs:vert
      frag: model_fs:frag
      properties: &props
        mProjection: { editor: { visible: false } }
        mModel: { editor: { visible: false } }
        fUV: { editor: { visible: false } }
        fModelColor: { editor: { visible: false } }
        mUVInversed: { editor: { visible: false } }
        predefined_uniform: { editor: { visible: false } }
        cameraPosition: { editor: { visible: false } }
        customData1: { editor: { visible: false } }
        customData2: { editor: { visible: false } }
        efk_uniform_348: { editor: { visible: false } }
        efk_uniform_358: { editor: { visible: false } }
        efk_uniform_370: { editor: { visible: false } }
        efk_uniform_479: { editor: { visible: false } }
        mUVInversedBack: { editor: { visible: false } }
        reconstructionParam1: { editor: { visible: false } }
        reconstructionParam2: { editor: { visible: false } }
        fLightDirection: { editor: { visible: false } }
        fLightColor: { editor: { visible: false } }
        fLightAmbient: { editor: { visible: false } }
}%

 
CCProgram user_vs %{
  precision highp float;
  
#define LAYOUT(ind)
#define in in
#define out out
#define centroid

#define MOD mod
#define FRAC fract
#define LERP mix
#define float2 vec2
#define float3 vec3
#define float4 vec4
#define half2 vec2
#define half3 vec3
#define half4 vec4
#define int2 ivec2
#define int3 ivec3
#define int4 ivec4

float atan2(in float y, in float x) {
  return x == 0.0 ? sign(y)* 3.141592 / 2.0 : atan(y, x);
}


// Dummy
float CalcDepthFade(vec2 screenUV, float meshZ, float softParticleParam) { return 1.0; }


LAYOUT(0) in vec3 Input_Pos;
LAYOUT(1) in vec4 Input_Color;
LAYOUT(2) in vec3 Input_Normal;
LAYOUT(3) in vec3 Input_Tangent;
LAYOUT(4) in vec2 Input_UV;
LAYOUT(5) in vec2 atTexCoord2;
LAYOUT(6) in vec2 atCustomData1;
LAYOUT(7) in vec2 atCustomData2;

LAYOUT(0) out lowp vec4 v_VColor;
LAYOUT(1) out mediump vec2 v_UV1;
LAYOUT(2) out mediump vec2 v_UV2;
LAYOUT(3) out mediump vec4 v_WorldN_PX;
LAYOUT(4) out mediump vec4 v_WorldB_PY;
LAYOUT(5) out mediump vec4 v_WorldT_PZ;
LAYOUT(6) out mediump vec4 v_PosP;
LAYOUT(7) out mediump vec2 v_CustomData1;
LAYOUT(8) out mediump vec2 v_CustomData2;
#define _INSTANCE_COUNT_ 10
LAYOUT(binding = 0) uniform sampler2D efk_texture_275;
LAYOUT(binding = 1) uniform sampler2D efk_texture_301;
LAYOUT(binding = 2) uniform sampler2D efk_background;
LAYOUT(binding = 3) uniform sampler2D efk_depth;
LAYOUT(binding = 0) uniform VSBlock {

  mat4 uMatCamera;
  mat4 uMatProjection;
  vec4 mUVInversed;
};

uniform EFK_COMMON {
  vec4 predefined_uniform;
  vec4 cameraPosition;
};
uniform EFK_UNIFORM_GRADIENT {
  vec4 efk_uniform_348;
  vec4 efk_uniform_358;
  vec4 efk_uniform_370;
  vec4 efk_uniform_479;
};

#define FLT_EPSILON 1.192092896e-07

float3 PositivePow(float3 base, float3 power)
{
  return pow(max(abs(base), float3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);
}

// based on http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
half3 SRGBToLinear(half3 c)
{
  return min(c, c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878));
}

half4 SRGBToLinear(half4 c)
{
  return half4(SRGBToLinear(c.rgb), c.a);
}

half3 LinearToSRGB(half3 c)
{
  return max(1.055 * PositivePow(c, float3(0.416666667,0.416666667,0.416666667)) - 0.055, 0.0);
}

half4 LinearToSRGB(half4 c)
{
  return half4(LinearToSRGB(c.rgb), c.a);
}

half4 ConvertFromSRGBTexture(half4 c)
{
  if (predefined_uniform.z == 0.0)
  {
    return c;
  }

  return LinearToSRGB(c);
}

half4 ConvertToScreen(half4 c)
{
  if (predefined_uniform.z == 0.0)
  {
    return c;
  }

  return SRGBToLinear(c);
}



vec2 GetUV(vec2 uv)
{
  uv.y = mUVInversed.x + mUVInversed.y * uv.y;
  return uv;
}

vec2 GetUVBack(vec2 uv)
{
  uv.y = mUVInversed.z + mUVInversed.w * uv.y;
  return uv;
}

vec4 vert() {
  vec3 worldPos = Input_Pos.xyz;
  vec3 objectScale = vec3(1.0, 1.0, 1.0);

  // Dummy
  vec2 screenUV = vec2(0.0, 0.0);
  float meshZ = 0.0;

  // UV
  vec2 uv1 = Input_UV.xy;
  //uv1.y = mUVInversed.x + mUVInversed.y * uv1.y;
  vec2 uv2 = atTexCoord2.xy;
  //uv2.y = mUVInversed.x + mUVInversed.y * uv2.y;

  // NBT
  vec3 worldNormal = (Input_Normal - vec3(0.5, 0.5, 0.5)) * 2.0;
  vec3 worldTangent = (Input_Tangent - vec3(0.5, 0.5, 0.5)) * 2.0;
  vec3 worldBinormal = cross(worldNormal, worldTangent);

  v_WorldN_PX.xyz = worldNormal;
  v_WorldB_PY.xyz = worldBinormal;
  v_WorldT_PZ.xyz = worldTangent;
  vec3 pixelNormalDir = worldNormal;
  vec4 vcolor = Input_Color;
  vec2 customData1 = atCustomData1;
  v_CustomData1 = customData1.xy;
  vec2 customData2 = atCustomData2;
  v_CustomData2 = customData2.xy;


float val0=customData1.x;
vec2 val1=customData2.xy;
vec2 val2=efk_uniform_370.xy;
vec2 val3=uv1;
vec2 val4=(val3*val2);
vec2 val5=(val4+val1);
vec4 val12 = ConvertFromSRGBTexture(texture(efk_texture_301,GetUV(val5)));
float val8=val12.x;
vec3 val7=val12.xyz;
float val13=(val8-float(0.5));
float val14=efk_uniform_479.x;
float val15=(val14*val13);
float val16=(val15+val0);
float val17= clamp(val16,float(0.0),float(1.0));
vec2 val18=efk_uniform_358.xy;
vec2 val19=efk_uniform_348.xy;
vec2 val20=uv1;
vec2 val21=(val20*val19);
vec2 val22=(val21+val18);
vec4 val29 = ConvertFromSRGBTexture(texture(efk_texture_275,GetUV(val22)));
float val28=val29.w;
vec3 val24=val29.xyz;
vec3 val30= vcolor.xyz;
float val34= vcolor.w;
float val35=(val34*val28);
float val36=(val35*val17);
vec3 val37=(val30*val24);
vec3 normalDir = vec3(0.5,0.5,1.0);
vec3 worldPositionOffset = vec3(0.0,0.0,0.0);
vec3 baseColor = vec3(0.0,0.0,0.0);
vec3 emissive = val37;
float metallic = float(0.5);
float roughness = float(0.5);
float ambientOcclusion = float(1.0);
float opacity = val36;
float opacityMask = float(1.0);
float refraction = float(0.0);



  worldPos = worldPos + worldPositionOffset;

  vec4 cameraPos = uMatCamera * vec4(worldPos, 1.0);
  cameraPos = cameraPos / cameraPos.w;

  v_PosP = uMatProjection * cameraPos;

  v_WorldN_PX.w = worldPos.x;
  v_WorldB_PY.w = worldPos.y;
  v_WorldT_PZ.w = worldPos.z;
  v_VColor = vcolor;

  v_UV1 = uv1;
  v_UV2 = uv2;
  //v_ScreenUV.xy = v_PosP.xy / v_PosP.w;
  //v_ScreenUV.xy = vec2(v_ScreenUV.x + 1.0, v_ScreenUV.y + 1.0) * 0.5;

  #ifdef _Y_INVERTED_
  v_PosP.y = - v_PosP.y;
  #endif

  return v_PosP;
}


}%

CCProgram user_fs %{
  precision highp float;
  
#define LAYOUT(ind)
#define in in
#define out out
#define centroid

#define MOD mod
#define FRAC fract
#define LERP mix
#define float2 vec2
#define float3 vec3
#define float4 vec4
#define half2 vec2
#define half3 vec3
#define half4 vec4
#define int2 ivec2
#define int3 ivec3
#define int4 ivec4

float atan2(in float y, in float x) {
  return x == 0.0 ? sign(y)* 3.141592 / 2.0 : atan(y, x);
}



LAYOUT(0) in lowp vec4 v_VColor;
LAYOUT(1) in mediump vec2 v_UV1;
LAYOUT(2) in mediump vec2 v_UV2;
LAYOUT(3) in mediump vec4 v_WorldN_PX;
LAYOUT(4) in mediump vec4 v_WorldB_PY;
LAYOUT(5) in mediump vec4 v_WorldT_PZ;
LAYOUT(6) in mediump vec4 v_PosP;
LAYOUT(7) in mediump vec2 v_CustomData1;
LAYOUT(8) in mediump vec2 v_CustomData2;

#define _INSTANCE_COUNT_ 10
LAYOUT(binding = 0) uniform sampler2D efk_texture_275;
LAYOUT(binding = 1) uniform sampler2D efk_texture_301;
LAYOUT(binding = 2) uniform sampler2D efk_background;
LAYOUT(binding = 3) uniform sampler2D efk_depth;
LAYOUT(binding = 0) uniform FSBlock {

  vec4 mUVInversedBack;
  vec4 reconstructionParam1;
  vec4 reconstructionParam2;
  vec4 fLightDirection;
  vec4 fLightColor;
  vec4 fLightAmbient;
};

uniform EFK_COMMON {
  vec4 predefined_uniform;
  vec4 cameraPosition;
};
uniform EFK_UNIFORM_GRADIENT {
  vec4 efk_uniform_348;
  vec4 efk_uniform_358;
  vec4 efk_uniform_370;
  vec4 efk_uniform_479;
};

#define FLT_EPSILON 1.192092896e-07

float3 PositivePow(float3 base, float3 power)
{
  return pow(max(abs(base), float3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);
}

// based on http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
half3 SRGBToLinear(half3 c)
{
  return min(c, c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878));
}

half4 SRGBToLinear(half4 c)
{
  return half4(SRGBToLinear(c.rgb), c.a);
}

half3 LinearToSRGB(half3 c)
{
  return max(1.055 * PositivePow(c, float3(0.416666667,0.416666667,0.416666667)) - 0.055, 0.0);
}

half4 LinearToSRGB(half4 c)
{
  return half4(LinearToSRGB(c.rgb), c.a);
}

half4 ConvertFromSRGBTexture(half4 c)
{
  if (predefined_uniform.z == 0.0)
  {
    return c;
  }

  return LinearToSRGB(c);
}

half4 ConvertToScreen(half4 c)
{
  if (predefined_uniform.z == 0.0)
  {
    return c;
  }

  return SRGBToLinear(c);
}



vec2 GetUV(vec2 uv)
{
  uv.y = mUVInversedBack.x + mUVInversedBack.y * uv.y;
  return uv;
}

vec2 GetUVBack(vec2 uv)
{
  uv.y = mUVInversedBack.z + mUVInversedBack.w * uv.y;
  return uv;
}

float CalcDepthFade(vec2 screenUV, float meshZ, float softParticleParam)
{
  float backgroundZ = TEX2D(efk_depth, GetUVBack(screenUV)).x;

  float distance = softParticleParam * predefined_uniform.y;
  vec2 rescale = reconstructionParam1.xy;
  vec4 params = reconstructionParam2;

  vec2 zs = vec2(backgroundZ * rescale.x + rescale.y, meshZ);

  vec2 depth = (zs * params.w - params.y) / (params.x - zs * params.z);
  float dir = sign(depth.x);
  depth *= dir;
  return min(max((depth.x - depth.y) / distance, 0.0), 1.0);
}

#ifdef _MATERIAL_LIT_

const float lightScale = 3.14;

float saturate(float v)
{
  return max(min(v, 1.0), 0.0);
}

float calcD_GGX(float roughness, float dotNH)
{
  float alpha = roughness*roughness;
  float alphaSqr = alpha*alpha;
  float pi = 3.14159;
  float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;
  return (alpha / denom) * (alpha / denom) / pi;
}

float calcF(float F0, float dotLH)
{
  float dotLH5 = pow(1.0-dotLH,5.0);
  return F0 + (1.0-F0)*(dotLH5);
}

float calcG_Schlick(float roughness, float dotNV, float dotNL)
{
  // UE4
  float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
  // float k = roughness * roughness / 2.0;

  float gV = dotNV*(1.0 - k) + k;
  float gL = dotNL*(1.0 - k) + k;

  return 1.0 / (gV * gL);
}

float calcLightingGGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)
{
  vec3 H = normalize(V+L);

  float dotNL = saturate( dot(N,L) );
  float dotLH = saturate( dot(L,H) );
  float dotNH = saturate( dot(N,H) ) - 0.001;
  float dotNV = saturate( dot(N,V) ) + 0.001;

  float D = calcD_GGX(roughness, dotNH);
  float F = calcF(F0, dotLH);
  float G = calcG_Schlick(roughness, dotNV, dotNL);

  return dotNL * D * F * G / 4.0;
}

vec3 calcDirectionalLightDiffuseColor(vec3 diffuseColor, vec3 normal, vec3 lightDir, float ao)
{
  vec3 color = vec3(0.0,0.0,0.0);

  float NoL = dot(normal,lightDir);
  color.xyz = fLightColor.xyz * lightScale * max(NoL,0.0) * ao / 3.14;
  color.xyz = color.xyz * diffuseColor.xyz;
  return color;
}

#endif

vec4 frag()
{
  vec2 uv1 = v_UV1;
  vec2 uv2 = v_UV2;
  vec3 worldPos = vec3(v_WorldN_PX.w, v_WorldB_PY.w, v_WorldT_PZ.w);
  vec3 worldNormal = v_WorldN_PX.xyz;
  vec3 worldTangent = v_WorldT_PZ.xyz;
  vec3 worldBinormal = v_WorldB_PY.xyz;
  vec3 pixelNormalDir = worldNormal;
  vec4 vcolor = v_VColor;
  vec3 objectScale = vec3(1.0, 1.0, 1.0);

  vec2 screenUV = v_PosP.xy / v_PosP.w;
  float meshZ =   v_PosP.z / v_PosP.w;
  screenUV.xy = vec2(screenUV.x + 1.0, screenUV.y + 1.0) * 0.5;

#ifdef _SCREEN_FLIPPED_
  screenUV.y = 1.0 - screenUV.y;
#endif
  vec2 customData1 = v_CustomData1;
  vec2 customData2 = v_CustomData2;


float val0=customData1.x;
vec2 val1=customData2.xy;
vec2 val2=efk_uniform_370.xy;
vec2 val3=uv1;
vec2 val4=(val3*val2);
vec2 val5=(val4+val1);
vec4 val12 = ConvertFromSRGBTexture(texture(efk_texture_301,GetUV(val5)));
float val8=val12.x;
vec3 val7=val12.xyz;
float val13=(val8-float(0.5));
float val14=efk_uniform_479.x;
float val15=(val14*val13);
float val16=(val15+val0);
float val17= clamp(val16,float(0.0),float(1.0));
vec2 val18=efk_uniform_358.xy;
vec2 val19=efk_uniform_348.xy;
vec2 val20=uv1;
vec2 val21=(val20*val19);
vec2 val22=(val21+val18);
vec4 val29 = ConvertFromSRGBTexture(texture(efk_texture_275,GetUV(val22)));
float val28=val29.w;
vec3 val24=val29.xyz;
vec3 val30= vcolor.xyz;
float val34= vcolor.w;
float val35=(val34*val28);
float val36=(val35*val17);
vec3 val37=(val30*val24);
vec3 normalDir = vec3(0.5,0.5,1.0);
vec3 worldPositionOffset = vec3(0.0,0.0,0.0);
vec3 baseColor = vec3(0.0,0.0,0.0);
vec3 emissive = val37;
float metallic = float(0.5);
float roughness = float(0.5);
float ambientOcclusion = float(1.0);
float opacity = val36;
float opacityMask = float(1.0);
float refraction = float(0.0);




  if(opacityMask <= 0.0) discard;
  if(opacity <= 0.0) discard;

  return ConvertToScreen(vec4(emissive, opacity));
}


}%

CCProgram model_vs %{
  precision highp float;
  
#define LAYOUT(ind)
#define in in
#define out out
#define centroid

#define MOD mod
#define FRAC fract
#define LERP mix
#define float2 vec2
#define float3 vec3
#define float4 vec4
#define half2 vec2
#define half3 vec3
#define half4 vec4
#define int2 ivec2
#define int3 ivec3
#define int4 ivec4

float atan2(in float y, in float x) {
  return x == 0.0 ? sign(y)* 3.141592 / 2.0 : atan(y, x);
}


// Dummy
float CalcDepthFade(vec2 screenUV, float meshZ, float softParticleParam) { return 1.0; }

LAYOUT(0) in vec3 Input_Pos;
LAYOUT(1) in vec3 Input_Normal;
LAYOUT(2) in vec3 Input_Binormal;
LAYOUT(3) in vec3 Input_Tangent;
LAYOUT(4) in vec2 Input_UV;
LAYOUT(5) in vec4 Input_Color;

LAYOUT(0) out lowp vec4 v_VColor;
LAYOUT(1) out mediump vec2 v_UV1;
LAYOUT(2) out mediump vec2 v_UV2;
LAYOUT(3) out mediump vec4 v_WorldN_PX;
LAYOUT(4) out mediump vec4 v_WorldB_PY;
LAYOUT(5) out mediump vec4 v_WorldT_PZ;
LAYOUT(6) out mediump vec4 v_PosP;
LAYOUT(7) out mediump vec2 v_CustomData1;
LAYOUT(8) out mediump vec2 v_CustomData2;
#define _INSTANCE_COUNT_ 10
LAYOUT(binding = 0) uniform sampler2D efk_texture_275;
LAYOUT(binding = 1) uniform sampler2D efk_texture_301;
LAYOUT(binding = 2) uniform sampler2D efk_background;
LAYOUT(binding = 3) uniform sampler2D efk_depth;
LAYOUT(binding = 0) uniform VSBlock {

  mat4 mProjection;
  mat4 mModel;
  vec4 fUV;
  vec4 fModelColor;
  vec4 mUVInversed;

  vec4 customData1;


  vec4 customData2;

};

uniform EFK_COMMON {
  vec4 predefined_uniform;
  vec4 cameraPosition;
};
uniform EFK_UNIFORM_GRADIENT {
  vec4 efk_uniform_348;
  vec4 efk_uniform_358;
  vec4 efk_uniform_370;
  vec4 efk_uniform_479;
};

#define FLT_EPSILON 1.192092896e-07

float3 PositivePow(float3 base, float3 power)
{
  return pow(max(abs(base), float3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);
}

// based on http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
half3 SRGBToLinear(half3 c)
{
  return min(c, c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878));
}

half4 SRGBToLinear(half4 c)
{
  return half4(SRGBToLinear(c.rgb), c.a);
}

half3 LinearToSRGB(half3 c)
{
  return max(1.055 * PositivePow(c, float3(0.416666667,0.416666667,0.416666667)) - 0.055, 0.0);
}

half4 LinearToSRGB(half4 c)
{
  return half4(LinearToSRGB(c.rgb), c.a);
}

half4 ConvertFromSRGBTexture(half4 c)
{
  if (predefined_uniform.z == 0.0)
  {
    return c;
  }

  return LinearToSRGB(c);
}

half4 ConvertToScreen(half4 c)
{
  if (predefined_uniform.z == 0.0)
  {
    return c;
  }

  return SRGBToLinear(c);
}



vec2 GetUV(vec2 uv)
{
  uv.y = mUVInversed.x + mUVInversed.y * uv.y;
  return uv;
}

vec2 GetUVBack(vec2 uv)
{
  uv.y = mUVInversed.z + mUVInversed.w * uv.y;
  return uv;
}


vec4 vert()
{
  mat4 modelMatrix = mModel;
  vec4 uvOffset = fUV;
  vec4 modelColor = fModelColor * Input_Color;

  mat3 modelMatRot = mat3(modelMatrix);
  vec3 worldPos = (modelMatrix * vec4(Input_Pos.xyz, 1.0)).xyz;
  vec3 worldNormal = normalize(modelMatRot * Input_Normal);
  vec3 worldBinormal = normalize(modelMatRot * Input_Binormal);
  vec3 worldTangent = normalize(modelMatRot * Input_Tangent);
  vec3 objectScale = vec3(1.0, 1.0, 1.0);

  // Calculate ObjectScale
  objectScale.x = length(modelMatRot * vec3(1.0, 0.0, 0.0));
  objectScale.y = length(modelMatRot * vec3(0.0, 1.0, 0.0));
  objectScale.z = length(modelMatRot * vec3(0.0, 0.0, 1.0));

  // UV
  vec2 uv1 = Input_UV.xy * uvOffset.zw + uvOffset.xy;
  vec2 uv2 = Input_UV.xy;

  //uv1.y = mUVInversed.x + mUVInversed.y * uv1.y;
  //uv1.y = mUVInversed.x + mUVInversed.y * uv1.y;

  vec3 pixelNormalDir = worldNormal;
  
  vec4 vcolor = modelColor;

  // Dummy
  vec2 screenUV = vec2(0.0, 0.0);
  float meshZ = 0.0;

  v_CustomData1 = customData1.xy;
  v_CustomData2 = customData2.xy;


float val0=customData1.x;
vec2 val1=customData2.xy;
vec2 val2=efk_uniform_370.xy;
vec2 val3=uv1;
vec2 val4=(val3*val2);
vec2 val5=(val4+val1);
vec4 val12 = ConvertFromSRGBTexture(texture(efk_texture_301,GetUV(val5)));
float val8=val12.x;
vec3 val7=val12.xyz;
float val13=(val8-float(0.5));
float val14=efk_uniform_479.x;
float val15=(val14*val13);
float val16=(val15+val0);
float val17= clamp(val16,float(0.0),float(1.0));
vec2 val18=efk_uniform_358.xy;
vec2 val19=efk_uniform_348.xy;
vec2 val20=uv1;
vec2 val21=(val20*val19);
vec2 val22=(val21+val18);
vec4 val29 = ConvertFromSRGBTexture(texture(efk_texture_275,GetUV(val22)));
float val28=val29.w;
vec3 val24=val29.xyz;
vec3 val30= vcolor.xyz;
float val34= vcolor.w;
float val35=(val34*val28);
float val36=(val35*val17);
vec3 val37=(val30*val24);
vec3 normalDir = vec3(0.5,0.5,1.0);
vec3 worldPositionOffset = vec3(0.0,0.0,0.0);
vec3 baseColor = vec3(0.0,0.0,0.0);
vec3 emissive = val37;
float metallic = float(0.5);
float roughness = float(0.5);
float ambientOcclusion = float(1.0);
float opacity = val36;
float opacityMask = float(1.0);
float refraction = float(0.0);



  worldPos = worldPos + worldPositionOffset;

  v_WorldN_PX.w = worldPos.x;
  v_WorldB_PY.w = worldPos.y;
  v_WorldT_PZ.w = worldPos.z;
  v_WorldN_PX.xyz = worldNormal;
  v_WorldB_PY.xyz = worldBinormal;
  v_WorldT_PZ.xyz = worldTangent;
  v_UV1 = uv1;
  v_UV2 = uv2;
  v_VColor = vcolor;
  v_PosP = mProjection * vec4(worldPos, 1.0);
//  v_ScreenUV.xy = v_PosP.xy / v_PosP.w;
//  v_ScreenUV.xy = vec2(v_ScreenUV.x + 1.0, v_ScreenUV.y + 1.0) * 0.5;

  #ifdef _Y_INVERTED_
  v_PosP.y = - v_PosP.y;
  #endif

  return v_PosP;
}

}%

CCProgram model_fs %{
  precision highp float;
  
#define LAYOUT(ind)
#define in in
#define out out
#define centroid

#define MOD mod
#define FRAC fract
#define LERP mix
#define float2 vec2
#define float3 vec3
#define float4 vec4
#define half2 vec2
#define half3 vec3
#define half4 vec4
#define int2 ivec2
#define int3 ivec3
#define int4 ivec4

float atan2(in float y, in float x) {
  return x == 0.0 ? sign(y)* 3.141592 / 2.0 : atan(y, x);
}



LAYOUT(0) in lowp vec4 v_VColor;
LAYOUT(1) in mediump vec2 v_UV1;
LAYOUT(2) in mediump vec2 v_UV2;
LAYOUT(3) in mediump vec4 v_WorldN_PX;
LAYOUT(4) in mediump vec4 v_WorldB_PY;
LAYOUT(5) in mediump vec4 v_WorldT_PZ;
LAYOUT(6) in mediump vec4 v_PosP;
LAYOUT(7) in mediump vec2 v_CustomData1;
LAYOUT(8) in mediump vec2 v_CustomData2;

#define _INSTANCE_COUNT_ 10
LAYOUT(binding = 0) uniform sampler2D efk_texture_275;
LAYOUT(binding = 1) uniform sampler2D efk_texture_301;
LAYOUT(binding = 2) uniform sampler2D efk_background;
LAYOUT(binding = 3) uniform sampler2D efk_depth;
LAYOUT(binding = 0) uniform FSBlock {

  vec4 mUVInversedBack;
  vec4 reconstructionParam1;
  vec4 reconstructionParam2;
  vec4 fLightDirection;
  vec4 fLightColor;
  vec4 fLightAmbient;
};

uniform EFK_COMMON {
  vec4 predefined_uniform;
  vec4 cameraPosition;
};
uniform EFK_UNIFORM_GRADIENT {
  vec4 efk_uniform_348;
  vec4 efk_uniform_358;
  vec4 efk_uniform_370;
  vec4 efk_uniform_479;
};

#define FLT_EPSILON 1.192092896e-07

float3 PositivePow(float3 base, float3 power)
{
  return pow(max(abs(base), float3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);
}

// based on http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
half3 SRGBToLinear(half3 c)
{
  return min(c, c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878));
}

half4 SRGBToLinear(half4 c)
{
  return half4(SRGBToLinear(c.rgb), c.a);
}

half3 LinearToSRGB(half3 c)
{
  return max(1.055 * PositivePow(c, float3(0.416666667,0.416666667,0.416666667)) - 0.055, 0.0);
}

half4 LinearToSRGB(half4 c)
{
  return half4(LinearToSRGB(c.rgb), c.a);
}

half4 ConvertFromSRGBTexture(half4 c)
{
  if (predefined_uniform.z == 0.0)
  {
    return c;
  }

  return LinearToSRGB(c);
}

half4 ConvertToScreen(half4 c)
{
  if (predefined_uniform.z == 0.0)
  {
    return c;
  }

  return SRGBToLinear(c);
}



vec2 GetUV(vec2 uv)
{
  uv.y = mUVInversedBack.x + mUVInversedBack.y * uv.y;
  return uv;
}

vec2 GetUVBack(vec2 uv)
{
  uv.y = mUVInversedBack.z + mUVInversedBack.w * uv.y;
  return uv;
}

float CalcDepthFade(vec2 screenUV, float meshZ, float softParticleParam)
{
  float backgroundZ = TEX2D(efk_depth, GetUVBack(screenUV)).x;

  float distance = softParticleParam * predefined_uniform.y;
  vec2 rescale = reconstructionParam1.xy;
  vec4 params = reconstructionParam2;

  vec2 zs = vec2(backgroundZ * rescale.x + rescale.y, meshZ);

  vec2 depth = (zs * params.w - params.y) / (params.x - zs * params.z);
  float dir = sign(depth.x);
  depth *= dir;
  return min(max((depth.x - depth.y) / distance, 0.0), 1.0);
}

#ifdef _MATERIAL_LIT_

const float lightScale = 3.14;

float saturate(float v)
{
  return max(min(v, 1.0), 0.0);
}

float calcD_GGX(float roughness, float dotNH)
{
  float alpha = roughness*roughness;
  float alphaSqr = alpha*alpha;
  float pi = 3.14159;
  float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;
  return (alpha / denom) * (alpha / denom) / pi;
}

float calcF(float F0, float dotLH)
{
  float dotLH5 = pow(1.0-dotLH,5.0);
  return F0 + (1.0-F0)*(dotLH5);
}

float calcG_Schlick(float roughness, float dotNV, float dotNL)
{
  // UE4
  float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
  // float k = roughness * roughness / 2.0;

  float gV = dotNV*(1.0 - k) + k;
  float gL = dotNL*(1.0 - k) + k;

  return 1.0 / (gV * gL);
}

float calcLightingGGX(vec3 N, vec3 V, vec3 L, float roughness, float F0)
{
  vec3 H = normalize(V+L);

  float dotNL = saturate( dot(N,L) );
  float dotLH = saturate( dot(L,H) );
  float dotNH = saturate( dot(N,H) ) - 0.001;
  float dotNV = saturate( dot(N,V) ) + 0.001;

  float D = calcD_GGX(roughness, dotNH);
  float F = calcF(F0, dotLH);
  float G = calcG_Schlick(roughness, dotNV, dotNL);

  return dotNL * D * F * G / 4.0;
}

vec3 calcDirectionalLightDiffuseColor(vec3 diffuseColor, vec3 normal, vec3 lightDir, float ao)
{
  vec3 color = vec3(0.0,0.0,0.0);

  float NoL = dot(normal,lightDir);
  color.xyz = fLightColor.xyz * lightScale * max(NoL,0.0) * ao / 3.14;
  color.xyz = color.xyz * diffuseColor.xyz;
  return color;
}

#endif

vec4 frag()
{
  vec2 uv1 = v_UV1;
  vec2 uv2 = v_UV2;
  vec3 worldPos = vec3(v_WorldN_PX.w, v_WorldB_PY.w, v_WorldT_PZ.w);
  vec3 worldNormal = v_WorldN_PX.xyz;
  vec3 worldTangent = v_WorldT_PZ.xyz;
  vec3 worldBinormal = v_WorldB_PY.xyz;
  vec3 pixelNormalDir = worldNormal;
  vec4 vcolor = v_VColor;
  vec3 objectScale = vec3(1.0, 1.0, 1.0);

  vec2 screenUV = v_PosP.xy / v_PosP.w;
  float meshZ =   v_PosP.z / v_PosP.w;
  screenUV.xy = vec2(screenUV.x + 1.0, screenUV.y + 1.0) * 0.5;

#ifdef _SCREEN_FLIPPED_
  screenUV.y = 1.0 - screenUV.y;
#endif
  vec2 customData1 = v_CustomData1;
  vec2 customData2 = v_CustomData2;


float val0=customData1.x;
vec2 val1=customData2.xy;
vec2 val2=efk_uniform_370.xy;
vec2 val3=uv1;
vec2 val4=(val3*val2);
vec2 val5=(val4+val1);
vec4 val12 = ConvertFromSRGBTexture(texture(efk_texture_301,GetUV(val5)));
float val8=val12.x;
vec3 val7=val12.xyz;
float val13=(val8-float(0.5));
float val14=efk_uniform_479.x;
float val15=(val14*val13);
float val16=(val15+val0);
float val17= clamp(val16,float(0.0),float(1.0));
vec2 val18=efk_uniform_358.xy;
vec2 val19=efk_uniform_348.xy;
vec2 val20=uv1;
vec2 val21=(val20*val19);
vec2 val22=(val21+val18);
vec4 val29 = ConvertFromSRGBTexture(texture(efk_texture_275,GetUV(val22)));
float val28=val29.w;
vec3 val24=val29.xyz;
vec3 val30= vcolor.xyz;
float val34= vcolor.w;
float val35=(val34*val28);
float val36=(val35*val17);
vec3 val37=(val30*val24);
vec3 normalDir = vec3(0.5,0.5,1.0);
vec3 worldPositionOffset = vec3(0.0,0.0,0.0);
vec3 baseColor = vec3(0.0,0.0,0.0);
vec3 emissive = val37;
float metallic = float(0.5);
float roughness = float(0.5);
float ambientOcclusion = float(1.0);
float opacity = val36;
float opacityMask = float(1.0);
float refraction = float(0.0);




  if(opacityMask <= 0.0) discard;
  if(opacity <= 0.0) discard;

  return ConvertToScreen(vec4(emissive, opacity));
}


}%
